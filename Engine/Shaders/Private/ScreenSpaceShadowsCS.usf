#include "SceneTextureParameters.ush"
#include "ScreenSpaceDenoise/SSDPublic.ush"


float4 LightPositionOrDirection; // xyzw = (position.xyz, 1/radius)
RWTexture2D<float2> RWShadowFactors;

#define THREADGROUP_SIZEX 8
#define THREADGROUP_SIZEY 8
#define DownsampleFactor 2

[numthreads(8, 8, 1)]
void Main(
    uint3 GroupId : SV_GroupID,  // 线程组ID，全局
	uint3 DispatchThreadId : SV_DispatchThreadID,    // 全局线程ID
    uint3 GroupThreadId : SV_GroupThreadID			// 线程组内的局部线程ID
)
{
	uint ThreadIndex = GroupThreadId.y * THREADGROUP_SIZEX + GroupThreadId.x;  // 局部线程索引
	float2 ScreenUV = (DispatchThreadId.xy * DownsampleFactor + View.ViewRectMin.xy + .5f) * View.BufferSizeAndInvSize.zw;  // 范围：[0,1]
	float2 ScreenPosition = (ScreenUV - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;  // [0, 1]的UV坐标转为[-1,1](OpenGL)或者[0,1]*[-1,1](DirectX)的NDC坐标，
																											// 在OpenGL中，View.ScreenPositionScaleBias的值可能为(2,2,0.5,0.5)，平移+缩放

	FGBufferData GBuffer = GetGBufferDataFromSceneTextures(ScreenUV);
	const float3 N = GBuffer.WorldNormal;
	const float SceneDepth = GBuffer.Depth;  // 距离相机最近的屏幕深度值

	const float4 PositionTranslatedWorld = mul(            // "TranslatedWorld"是UE的坐标系（世界空间减去相机相对原点），计算像素实际的深度值（世界）
		float4(ScreenPosition * SceneDepth, SceneDepth, 1),     
		View.ScreenToTranslatedWorld
	);

	RWShadowFactors[DispatchThreadId.xy] = float2(1, 0);
}